[{"title":"二维图形变换&裁剪","date":"2020-11-16T08:22:18.422Z","url":"/2020/11/16/%E4%BA%8C%E7%BB%B4%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2&%E8%A3%81%E5%89%AA/","categories":[["undefined",""]],"content":"算法描述1.基本变换矩阵(1).缩放矩阵 (2).旋转矩阵 (3).平移矩阵 2.Cohn-Sutherland直线裁剪算法Cohn-Sutherland直线裁剪算法即对直线段p1(x1 ,y1)、p2(x2 ,y2)进行裁剪 1.基本思想：对每条直线段p1(x1,y1)p2(x2,y2)分三种情况处理 直线段完全可见，“简取”之。 直线段完全不可见，“简弃”之。 直线段既不满足“简取”的条件，也不满足“简弃”的条件，需要对直线段按交点进行分段，分段后重复上述处理。 2 编码方法编码： 对于任一端点(x,y)，根据其坐标所在的区域，赋予一个4位的二进制码D3D2D1D0。 编码规则如下： 若x&lt;wxl，则D0=1，否则D0=0； 若x&gt;wxr，则D1=1，否则D1=0； 若y&lt;wyb，则D2=1，否则D2=0； 若y&gt;wyt，则D3=1，否则D3=0。 裁剪一条线段时，先求出端点p1和p2的编码 code1和code2，然后： 若code1|code2=0，对直线段应简取之。 若code1&amp;code2≠0，对直线段可简弃之。 若上述两条件均不成立。则需求出直线段与窗口边界的交点。在交点处把线段一分为二， 其中必有一段完全在窗口外，可以弃之。再对另一段重复进行上述处理，直到该线段完全被舍弃或者找到位于窗口内的一段线段为止。3.具体做法：按左、下、右、上的顺序求出直线段与窗口边界的交点，分段处理 例：对于直线段P1P2 求出P1P2与左边界有实交点P3，一分为二，简弃直线段P1P3，处理P2P3 求出P2P3与下边界的实交点P4，一分为二，简弃P2P4，剩下的P3P4可以简取。 3. Liang-Barsky直线裁剪算法：任意直线段I（X1 ,Y1）J(X2 ,Y2 )的参数方程： x=x1+u•(x2 -x1)y=y1+u•(y2 -y1) （0 ≤ u ≤ 1） 给定裁剪窗口，如果任一点在窗口内则： wxl≤ x1+u•(x2 -x1 )≤ wxrwyb≤y1+u•(y2 -y1 ) ≤ wyt u•(x1 -x2 )≤ x1 – wxl 左边界 u•(x2 -x1 )≤ wxr – x1 右边界u•(y1 -y2 )≤ y1 – wyb 下边界 u•(y2 -y1 ) ≤ wyt – y1 上边界 （u•pk≤qk ，k=1,2,3,4） 令：p1 = x1 -x2 p2 = x2 -x1p3 = y1 -y2 p4 = y2 -y1 q1 = x1 – wxl q2 = wxr – x1 q3 = y1 – wybq4 = wyt – y1（u•pk≤qk，其中：k=1,2,3,4） 取“=”时求得的u对应的是直线不窗口边界的交点 1、2、3、4分别对应左、右、下、上边界 u=0和1时分别对应直线的起点和终点Uone=max(0,uk|pk&lt;0,uk|pk&lt;0)Utwo=min(1,uk|pk&gt;0,uk|pk&gt;0) 例如： 对于IJ P1、P4小于0 Uone在0、u1、u4取大者 P2、P3大于0 Utwo在1、u2、u3取小者限制条件： 如果Uone≤ Utwo取可求得两端点 4. Sutherland-Hodgman多边形裁剪算法1.基本思想：一次用窗口的一条边来裁剪多边形。算法的输入是以顶点序列表示的多边形，输出也是一个顶点序列，这些顶点能够构成一个或多个多边形。 处理对象： 任意凸多边形。 窗口的任意一条边的所在直线（裁剪线）把窗口所在平面分成两部分： 可见一侧：包含窗口那部分 不可见一侧：不包含窗口那部分 2. 算法说明：1、已知：多边形顶点数组src，顶点个数n，定义新多边形顶点数组dest。 2、赋初值：用变量flag来标识：0表示在内侧，1表示在外侧。 3、对多边形的n条边进行处理，对当前点号的考虑为：0～n-1。 3.算法特点：Sutherland－Hodgeman多边形裁剪算法具有一般性，被裁剪多边形可以是任意凸多边形，裁剪窗口不局限于矩形。 上面的算法是多边形相对窗口的一条边界进行裁剪的实现，对于窗口的每一条边界依次调用该算法程序，并将前一次裁剪的结果多边形作为下一次裁剪时的被裁剪多边形，即可得到完整的多边形裁剪程序。 5. Weiler－Atherton多边形裁剪算法一．Weiler－Atherton任意多边形裁剪算法思想：假设被裁剪多边形和裁剪窗口的顶点序列都按顺时针方向排列。当两个多边形相交时，交点必然成对出现，其中一个是从被裁剪多边形进入裁剪窗口的交点，称为“入点”，另一个是从被裁剪多边形离开裁剪窗口的交点，称为“出点”。算法从被裁剪多边形的一个入点开始，碰到入点，沿着被裁剪多边形按顺时针方向搜集顶点序列；而当遇到出点时，则沿着裁剪窗口按顺时针方向搜集顶点序列。按上述规则，如此交替地沿着两个多边形的边线行进，直到回到起始点。这时，收集到的全部顶点序列就是裁剪所得的一个多边形。由于可能存在分裂的多边形，因此算法要考虑：将搜集过的入点的入点记号删去，以免重复跟踪。将所有的入点搜集完毕后算法结束。 二．Weiler－Atherton任意多边形裁剪算法步骤： 顺时针输入被裁剪多边形顶点序列Ⅰ放入数组1中。 顺时针输入裁剪窗口顶点序列Ⅱ放入数组2中。 求出被裁剪多边形和裁剪窗口相交的所有交点，并给每个交点打上“入”、“出”标记。 然后将交点按顺序插入序列Ⅰ得到新的顶点序列Ⅲ，并放入数组3中； 同样也将交点按顺序插入序列Ⅱ得到新的顶点序列Ⅳ，放入数组4中； 初始化输出数组Q，令数组Q为空。接着从数组3中寻找“入”点。如果“入”点没找到，程序结束。 如果找到“入”点，则将“入”点放入S中暂存。 将“入”点录入到输出数组Q中。并从数组3中将该“入”点的“入”点标记删去。 沿数组3顺序取顶点：如果顶点不是“出点”，则将顶点录入到输出数组Q中，流程转第7步。否则，流程转第8步。 沿数组4顺序取顶点：如果顶点不是“入点”，则将顶点录入到输出数组Q中，流程转第8步。否则，流程转第9步。 如果顶点不等于起始点S，流程转第6步，继续跟踪数组3。否则，将数组Q输出；流程转第4步，寻找可能存在的分裂多边形。算法在第4步：满足“入”点没找到的条件时，算法结束。算法的生成过程见下图所示。三．Weiler－Atherton任意多边形裁剪算法特点： 裁剪窗口可以是矩形、任意凸多边形、任意凹多边形。 可实现被裁剪多边形相对裁剪窗口的内裁或外裁，即保留窗口内的图形或保留窗口外的图形，因此在三维消隐中可以用来处理物体表面间的相互遮挡关系。3、裁剪思想新颖，方法简洁，裁剪一次完成，与裁剪窗口的边数无关。 源码参考（C++）1.基本变换矩阵 2.绘制直线 3.直线2D变换 4.直线裁剪1.Cohn-Sutherland Subdivision Line Clip 2.Liang-Barsky Line Clip 5.绘制多边形 6.多边形2D变换 7.多边形裁剪Sutherland-Hodgman Polygon Clip"},{"title":"直线生成算法","date":"2020-11-16T00:31:20.123Z","url":"/2020/11/16/%E7%9B%B4%E7%BA%BF%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/","categories":[["undefined",""]],"content":"综述直线的扫描转换是指在图形输出设备上，按照扫描线的顺序，确定一组最佳逼近于直线的像素点并对像素进行写操作。直线生成的具体问题是已知直线的两个端点,要求在图像输出设备上从起点到中点通过逐次循环迭代，找到最接近直线的像素点集合。 所涉及的算法有三种：DDA算法、B算法和重点分割法。在MFC环境中测试三种算法并对比分析三种算法的误差及效率。 程序框架 实验程序为MFC框架： CCgDrawLineView.h为视图层的头文件，负责声明各种成员变量和成员函数； CCgDrawLineView.cpp为视图层的源文件，负责实现直线的三种绘制、误差分析并显示、圆与圆弧绘制的功能。 CCgEditControl.h为窗口面板中的按键及文本定义成员变量及成员函数。 CCgEditControl.cpp实现面板的功能，如点击按键绘制图像、分析误差等。 算法描述1. DDA算法（1）将给定端点作为输入参数； （2）初始化，初值加上0.5确保精度； （3）计算起止点水平和垂直的差值dx和dy，选取较大者为最大位移，并作为迭代步数step； （4）从起始点开始确定相邻两点间的增量并进行地推计算。 若dx&gt;dy,且x1&lt;x2，则x和y方向上的增量分别为1和斜率m，若dx&gt;dy,且x1&gt;=x2，则x和y方向上的增量分别为-1和斜率-m； 若dx&lt;=dy,且x1&lt;x2，则x和y方向上的增量分别为1/m和1，若dx&lt;=dy,且x1&gt;=x2，则x和y方向上的增量分别为-1/m和-1。 （5）重复上一步直到循环结束； （6）将所求得坐标取整并设置颜色值。 源代码参考： 2. B算法（1）确定最大位移方向并计算误差初值e = 2 * min - max;（min和max分别为水平距离和垂直距离的最值） （2）设置点(Xi, Yi) 的颜色值，并求下一误差ei+1； 如果 ei &gt; 0 则ei+1 = e - 2 * max;； 否则ei+1 = ei + 2 * min； （3）根据不同象限，确定x和y变化符号的正负，进行下一次循环； （4）如果没有结束，则转到步骤2，3；否则结束。 源代码参考： 3. 中点分割法（1）将直线段求中点坐标，若可以细分，则进行一次递归； （2）如果中点坐标无法继续递归，则设置改像素的颜色值； （3）执行至所有点都完成了颜色值的设置，程序结束。 源代码参考： 中点分割算法误差分析： 4. 算法误差分析参数说明：（1）RunTime为多条直线生成的所有运行时间。本实验中三种直线算法生成的直线均相同，便于直接得出结果。时间越短，效率越高。 （2）Error为直线生成算法所计算出的生成点距离理论直线距离的平均值，作为算法的误差。误差越小，算法精度越高。 （3）Smooth为直线生成算法所计算出的生成点与直线起始点所连直线的斜率的平均值，作为平滑度。平滑度越小，直线斜率越接近理论斜率，越平滑。 5. B圆弧生成算法（1）确定误差初值d = 2 * (1 - r)，设置x = 0，y = r; （2）设置当前点(Xi, Yi) 的颜色值，并求下一误差di+1及下一点坐标： 如果d &lt; 0，d1 = 2 * (d + y) - 1; 如果d1 &lt; 0，x++;di+1 += 2 * x + 1; 否则x++;y–; di+1 += 2 * (x - y + 1); 如果d &gt; 0，d2 = 2 * (d - x) - 1; 如果d2 &lt; 0，x++;y–; di+1 += 2 * (x - y + 1); 否则y–; di+1 += -2 * y + 1; （3）如果没有结束，重复上一步，直到循环结束。 源代码参考： 6. B圆弧段生成算法算法原理同B圆弧生成算法，通过变换，找出符合特定起始值的圆弧段。 源代码参考： B任意弧度圆弧生成算法 处理流程 首先建立直角坐标系 ２. 当点击DDA Line时调用DDA直线生成函数 ３. 当点击B Line时调用B直线生成函数 ４. 当点击MidPoint时调用中点分割直线生成函数 ５. 点击Comparision时先后调用三种直线生成函数，并绘制在同一坐标系中，便于观察对比，并计算出调用时间、误差和光滑度 其中，RunTime值越低表示效率越高，Error越小表示误差越小，Smooth越小表示直线越光滑。 ６. 当点击Circle时调用B算法圆生成函数 ７. 当点击Arc时调用B算法任意弧度圆弧生成函数 算法对比从误差结果来看，DDA算法时间较长，B算法精度最高，误差最小，重点分割法误差较大，且重点分割法平滑度较低，不如DDA算法和B算法。因此： DDA算法的缺点在于存在除法运算和浮点数，使得程序运行时间延长，会降低程序运行的效率，优点是较为简单，直接明了。 Bresenham算法的优点在于只有加减运算，因此算法实现效率高，速度快，且精度较高。 中点分割法较为简单，但缺点在于生成的直线较为粗糙，精度较低。 "},{"title":"Hello World","date":"2020-11-15T14:46:43.692Z","url":"/2020/11/15/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]